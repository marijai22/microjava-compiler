package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import rs.ac.bg.etf.pp1.ast.*;
import rs.etf.pp1.mj.runtime.Code;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.Obj;
import rs.etf.pp1.symboltable.concepts.Struct;

public class CodeGenerator extends VisitorAdaptor {

	private int mainPc;
	
	public int getmainPc() {
		return this.mainPc;
	}
	
	
	private void loadPredclMethods() {
        //ord i chr
        Obj ordMethod = Tab.find("ord");
        Obj chrMethod = Tab.find("chr");
        ordMethod.setAdr(Code.pc);
        chrMethod.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.exit);
        Code.put(Code.return_);
 
        Obj lenMethod = Tab.find("len");
        lenMethod.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(1);
        Code.put(1);
        Code.put(Code.load_n);
        Code.put(Code.arraylength);
        Code.put(Code.exit);
        Code.put(Code.return_);
        
        Obj addMethod = Tab.find("add");
        Obj aObj = Tab.noObj, bObj = Tab.noObj, lenObj = Tab.noObj, iObj = Tab.noObj;
        
        addMethod.setAdr(Code.pc);
        Code.put(Code.enter);
        Code.put(addMethod.getLevel());
        Code.put(addMethod.getLocalSymbols().size());
        
        
        for (Obj o : addMethod.getLocalSymbols()) {
            switch (o.getName()) {
                case "addA": aObj = o; break; // mislim da se ova prva 2 formalna sama napune
                case "addB": bObj = o; break;
                case "length": lenObj = o; break; 
                case "iterAdd": iObj = o; break;
            }
        }
        
        // duzina niza
        Code.load(aObj);        // učitaj adresu niza a
        Code.put(Code.arraylength); // na steku sada dužina niza a
        Code.store(lenObj);
        
        // i = 1;
        Code.put(Code.const_1);
        Code.store(iObj);
        
        // while (i <= a[0])
        int loopStart = Code.pc;
        
        Code.load(iObj);      // i
        Code.load(aObj);      // a
        Code.put(Code.const_n);
        Code.put(Code.aload); // a[0]
      
        Code.putFalseJump(Code.le, 0); // ako i > a[0] -> izlaz
        int exitJumpAddr = Code.pc - 2;
        
        
        // if (a[i] == b) -> skip dodavanje
        Code.load(aObj);
        Code.load(iObj);
        Code.put(Code.aload);     // a[i]
        
        Code.load(bObj);          // b
        Code.putFalseJump(Code.ne, 0); // ako a[i] == b -> return
        int skipAddJumpAddr = Code.pc - 2;
       
        
        // i = i + 1;
        Code.load(iObj);
        Code.put(Code.const_1);
        Code.put(Code.add);
        Code.store(iObj);
        
        // skok nazad na početak petlje
        Code.putJump(loopStart);
        
        // adresa na koju se ide ako je i > a[0]
        Code.fixup(exitJumpAddr);
        
        // a[0] + 1 >= len -> nema mesta
        Code.load(aObj);
        Code.put(Code.const_n);
        Code.put(Code.aload);  // a[0]
        Code.put(Code.const_1);
        Code.put(Code.add);    // a[0] + 1
        
        Code.load(lenObj);     // len
        Code.putFalseJump(Code.lt, 0); // ako (a[0] + 1) >= len -> return
        int noSpaceJumpAddr = Code.pc - 2;
        
        // dodavanje b na a[a[0] + 1]
        Code.load(aObj);
        Code.load(aObj);
        Code.put(Code.const_n);
        Code.put(Code.aload); // a[0]
        Code.put(Code.const_1);
        Code.put(Code.add);   // index = a[0] + 1
        Code.load(bObj);      // b
        Code.put(Code.astore); // a[a[0] + 1] = b
        
        // a[0] = a[0] + 1;
        Code.load(aObj);         // adr
        Code.put(Code.const_n);  // index
        Code.load(aObj);         // za aload
        Code.put(Code.const_n);  // index
        Code.put(Code.aload);    // a[0]
        Code.put(Code.const_1);  
        Code.put(Code.add);      // a[0] + 1
        Code.put(Code.astore);   
        
        
        // exit, return
        Code.fixup(skipAddJumpAddr);
        Code.fixup(noSpaceJumpAddr);
        Code.put(Code.exit);
        Code.put(Code.return_);
 
        
        
        
        
        Obj addAllMethod = Tab.find("addAll");
        Obj aAObj = Tab.noObj, bAObj = Tab.noObj, iAObj = Tab.noObj;
        addAllMethod.setAdr(Code.pc);
        
        Code.put(Code.enter);
        Code.put(addAllMethod.getLevel());
        Code.put(addAllMethod.getLocalSymbols().size());
        
        for (Obj o : addAllMethod.getLocalSymbols()) {
            switch (o.getName()) {
                case "addAllA": aAObj = o; break; // mislim da se ova prva 2 formalna sama napune
                case "addAllB": bAObj = o; break;
                case "iterAddAll": iAObj = o; break;
            }
        }
        
        // i = 0;
        Code.loadConst(0);
        Code.store(iAObj);
        
        int loopAStart = Code.pc;
        
        // if (i >= b.length) -> izlaz
        Code.load(iAObj);  // i
        Code.load(bAObj);  // b
        Code.put(Code.arraylength); // len(b)
        Code.putFalseJump(Code.lt, 0); // if i >= len(b)
        int exitAJumpAddr = Code.pc - 2;
        
        
        
        Code.load(aAObj); // a
      
        Code.load(bAObj); // b
        Code.load(iAObj);
        Code.put(Code.aload);
        
        // poziv add(a, b[i])
        int offs = addMethod.getAdr() - Code.pc;
        Code.put(Code.call);
        Code.put2(offs);
        
        // i++
        Code.load(iAObj);
        Code.loadConst(1);
        Code.put(Code.add);
        Code.store(iAObj);
        
        // skok nazad na početak
        Code.putJump(loopAStart);
        
        // patch uslovnog skoka
        Code.fixup(exitAJumpAddr);
        
        // exit, return
        Code.put(Code.exit);
        Code.put(Code.return_);
        

        
    }
	
	CodeGenerator() {
		this.loadPredclMethods();
	}
	
	
	@Override
	public void visit(MethodDecl methodDecl) {
		Code.put(Code.exit);
		Code.put(Code.return_);
	}
	
	@Override
	public void visit(ReturnType_t returnType_t) {
		returnType_t.obj.setAdr(Code.pc);
		
		Code.put(Code.enter);
		Code.put(returnType_t.obj.getLevel()); //b1 - broj formalnih parametara
		Code.put(returnType_t.obj.getLocalSymbols().size()); // b2 - locals (broj formalnih i lokalnih parametara)
	}
	
	@Override
	public void visit(ReturnType_v returnType_v) {
		returnType_v.obj.setAdr(Code.pc);
		if(returnType_v.getI1().equalsIgnoreCase("main")) {
			this.mainPc = Code.pc;
		}
		
		Code.put(Code.enter);
		Code.put(returnType_v.obj.getLevel());
		Code.put(returnType_v.obj.getLocalSymbols().size());
	}
	
	
	
	
	
	@Override
	public void visit(Statement_rs statement_rs) {
		Code.put(Code.exit);
		Code.put(Code.return_);
	}
	
	
	@Override
	public void visit(Statement_res statement_res) {
		Code.put(Code.exit);
		Code.put(Code.return_);
	}
	
	
	@Override
	public void visit(Statement_rd statement_rd) {
		if(statement_rd.getDesignator().obj.getType().equals(Tab.charType)) {
			Code.put(Code.bread);
		}
		else {
			Code.put(Code.read);
		}
		Code.store(statement_rd.getDesignator().obj);
	}
	
	
	@Override
	public void visit(Statement_pre statement_pre) {
		if(statement_pre.getExpr().struct.getKind() == Struct.Enum) {
		
			Code.put(Code.dup);             // addr, addr
			Code.loadConst(0);              // addr, addr, 0
			Code.put(Code.aload);           // addr, s[0]
	
			// i = 1
			Code.loadConst(1);              // addr, s[0], 1
			
			Code.put(Code.dup_x1);			// addr, i, s[0], i
			Code.put(Code.dup_x1);			// addr, i, i, s[0], i
			Code.put(Code.pop);				// addr, i, i, s[0]
			
			int loopStart = Code.pc;
			
			// i <= s[0]
			Code.put(Code.dup2);            // addr, i, i, s[0], i, s[0]
			Code.putFalseJump(Code.le, 0);  //  i > s[0] -> skok van petlje
			int exitJump = Code.pc - 2;
			
			// addr, i, i, s[0]
			
			Code.put(Code.pop);             // addr, i, i
			Code.put(Code.pop);             // addr, i
	
			
			Code.put(Code.dup2);            // addr, i, addr, i
			Code.put(Code.aload);           // addr, i, s[i]
	
			// print
			Code.loadConst(0);              // addr, i, s[i], 0
			Code.put(Code.print);           // addr, i
			Code.loadConst(32);
			Code.loadConst(0);
			Code.put(Code.bprint); 
			
			// i++
			Code.loadConst(1);              // addr, i, 1
			Code.put(Code.add);             // addr, i+1
			
			// pripremamo stek za sledecu iteraciju -> addr, i, i, s[0] 
			Code.put(Code.dup2);             // addr, i, addr, i
			Code.put(Code.dup);				// addr, i, addr, i, i
			Code.put(Code.dup_x2);			// addr, i, i, addr, i, i
			
			Code.put(Code.pop);				 // addr, i, i, addr, i
			Code.put(Code.pop);				 // addr, i, i, addr
			Code.loadConst(0);              // addr, i, i, addr, 0
			Code.put(Code.aload);  			// addr, i, i, s[0]
			
			// addr, i, i, s[0]
	
			// skok na početak petlje
			Code.putJump(loopStart);
	
			// patch skoka za izlaz
			Code.fixup(exitJump);
	
			// ciscenje steka
			Code.put(Code.pop);             
			Code.put(Code.pop);             
			Code.put(Code.pop);
			Code.put(Code.pop);             
		}
		else {
			Code.loadConst(0);
			if(statement_pre.getExpr().struct.equals(Tab.charType)) {
				Code.put(Code.bprint);
			}
			else {
				Code.put(Code.print);
			}
		}
	}
	
	@Override
	public void visit(Statement_prc statement_prc) {
		if(statement_prc.getExpr().struct.getKind() == Struct.Enum) {
	
			Code.put(Code.dup);             // addr, addr
			Code.loadConst(0);              // addr, addr, 0
			Code.put(Code.aload);           // addr, s[0]

			// i = 1
			Code.loadConst(1);              // addr, s[0], 1
			
			Code.put(Code.dup_x1);			// addr, i, s[0], i
			Code.put(Code.dup_x1);			// addr, i, i, s[0], i
			Code.put(Code.pop);				// addr, i, i, s[0]
			
			int loopStart = Code.pc;
			
			//i <= s[0]
			Code.put(Code.dup2);            // addr, i, i, s[0], i, s[0]
			Code.putFalseJump(Code.le, 0); //  i > s[0] -> skok van petlje
			int exitJump = Code.pc - 2;
			
			// addr, i, i, s[0]
			
			Code.put(Code.pop);             // addr, i, i
			Code.put(Code.pop);             // addr, i

			Code.put(Code.dup2);            // addr, i, addr, i
			Code.put(Code.aload);           // addr, i, s[i]

			// print
			Code.loadConst(statement_prc.getN2());      // addr, i, s[i], 0
			Code.put(Code.print);           // addr, i
			Code.loadConst(32);
			Code.loadConst(0);
			Code.put(Code.bprint);
			
			// i++
			Code.loadConst(1);              // addr, i, 1
			Code.put(Code.add);             // addr, i+1
			
			// pripremamo stek za sledecu iteraciju ->  addr, i, i, s[0] 
			Code.put(Code.dup2);             // addr, i, addr, i
			Code.put(Code.dup);				// addr, i, addr, i, i
			Code.put(Code.dup_x2);				// addr, i, i, addr, i, i
			
			Code.put(Code.pop);				 // addr, i, i, addr, i
			Code.put(Code.pop);				 // addr, i, i, addr
			Code.loadConst(0);              // addr, i, i, addr, 0
			Code.put(Code.aload);  			// addr, i, i, s[0]
			
			// addr, i, i, s[0]

			// skok na početak petlje
			Code.putJump(loopStart);

			// patch skoka za izlaz
			Code.fixup(exitJump);

			// ciscenje steka
			Code.put(Code.pop);             
			Code.put(Code.pop);             
			Code.put(Code.pop);
			Code.put(Code.pop);             
		}
		else {
			Code.loadConst(statement_prc.getN2());
			if(statement_prc.getExpr().struct.equals(Tab.charType)) {
				Code.put(Code.bprint);
			}
			else {
				Code.put(Code.print);
			}
		}
	}
	
	
	
	//Designator Statements
	@Override
	public void visit(DesignatorStatement_ass designatorStatement_ass) {
		Code.store(designatorStatement_ass.getDesignator().obj);
	}
	
	
	@Override
	public void visit(DesignatorStatement_dp designatorStatement_dp) {
		int offset = designatorStatement_dp.getDesignator().obj.getAdr() - Code.pc;
		Code.put(Code.call);
		Code.put2(offset);
		
		if(!designatorStatement_dp.getDesignator().obj.getType().equals(Tab.noType)) {
			Code.put(Code.pop);
		}
	}
	
	@Override
	public void visit(DesignatorStatement_inc designatorStatement_inc) {
		if(designatorStatement_inc.getDesignator().obj.getKind() == Obj.Elem) {
			Code.put(Code.dup2); // za dupliranje poslednje 2 vrednosti
		}
		Code.load(designatorStatement_inc.getDesignator().obj);
		Code.loadConst(1);
		Code.put(Code.add);
		Code.store(designatorStatement_inc.getDesignator().obj);
	}
	
	@Override
	public void visit(DesignatorStatement_dec designatorStatement_dec) {
		if(designatorStatement_dec.getDesignator().obj.getKind() == Obj.Elem) {
			Code.put(Code.dup2); // za dupliranje poslednje 2 vrednosti
		}
		Code.load(designatorStatement_dec.getDesignator().obj);
		Code.loadConst(1);
		Code.put(Code.sub);
		Code.store(designatorStatement_dec.getDesignator().obj);
	}
	
	@Override
	public void visit(DesignatorStatement_dadsd designatorStatement_dadsd) {
		Obj s3Obj = designatorStatement_dadsd.getDesignator().obj;
		Obj s1Obj = designatorStatement_dadsd.getDesignator1().obj;
		Obj s2Obj = designatorStatement_dadsd.getDesignator2().obj;
		Obj addMethod = Tab.find("add");
		
		// s1 petlja
		
		Code.load(s1Obj); 				// s1
		Code.put(Code.dup);             // s1, s1
		Code.loadConst(0);              // s1, s1, 0
		Code.put(Code.aload);           // s1, s1[0]
		Code.loadConst(1);              // s1, s1[0], 1
		Code.put(Code.dup_x1);          // s1, 1, s1[0], 1
		Code.put(Code.dup_x1);          // s1, 1, 1, s1[0], 1
		Code.put(Code.pop);             // s1, 1, 1, s1[0]

		int loopStart1 = Code.pc;
		
		Code.put(Code.dup2);            // s1, i, i, s1[0], i, s1[0]
		Code.putFalseJump(Code.le, 0);  // i > s1[0] -> exit
		int exitJump1 = Code.pc - 2;

		// s1, i, i, s1[0]
		Code.put(Code.pop);             // s1, i, i
		Code.put(Code.pop);             // s1, i
		Code.put(Code.dup2);            // s1, i, s1, i
		Code.put(Code.aload);           // s1, i, elem
		Code.load(s3Obj);               // s1, i, elem, s3
		Code.put(Code.dup_x1);          // s1, i, s3, elem, s3
		Code.put(Code.pop);  			// s1, i, s3, elem
		
		// poziv add(s3, elem)

		int offset1 = addMethod.getAdr() - Code.pc;
		Code.put(Code.call); 
		Code.put2(offset1);
		
		// i++
		Code.loadConst(1);              // s1, i, 1
		Code.put(Code.add);             // s1, i+1

		// priprema za sledeću iteraciju
		Code.put(Code.dup2);            // s1, i, s1, i
		Code.put(Code.dup);             // s1, i, s1, i, i
		Code.put(Code.dup_x2);          // s1, i, i, s1, i, i
		Code.put(Code.pop);             // s1, i, i, s1, i
		Code.put(Code.pop);             // s1, i, i, s1
		Code.loadConst(0);              // s1, i, i, s1, 0
		Code.put(Code.aload);           // s1, i, i, s1[0]
		
		Code.putJump(loopStart1);
		Code.fixup(exitJump1);
		
		// ciscenje steka
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.put(Code.pop);
		
		
		// s2 petlja

		Code.load(s2Obj); 				// s2
		Code.put(Code.dup);             // s2, s2
		Code.loadConst(0);              // s2, s2, 0
		Code.put(Code.aload);           // s2, s2[0]
		Code.loadConst(1);              // s2, s2[0], 1
		Code.put(Code.dup_x1);          // s2, 1, s2[0], 1
		Code.put(Code.dup_x1);          // s2, 1, 1, s2[0], 1
		Code.put(Code.pop);             // s2, 1, 1, s2[0]

		int loopStart2 = Code.pc;
		
		Code.put(Code.dup2);            // s2, i, i, s2[0], i, s2[0]
		Code.putFalseJump(Code.le, 0);  // i > s2[0] ->  exit
		int exitJump2 = Code.pc - 2;
		
		// s2, i, i, s2[0]
		Code.put(Code.pop);             // s2, i, i
		Code.put(Code.pop);             // s2, i
		Code.put(Code.dup2);            // s2, i, s2, i
		Code.put(Code.aload);           // s2, i, elem
		Code.load(s3Obj);               // s2, i, elem, s3
		Code.put(Code.dup_x1);          // s2, i, s3, elem, s3
		Code.put(Code.pop);  			// s2, i, s3, elem
		
		
		// poziv add(s3, elem)

		int offset2 = addMethod.getAdr() - Code.pc;
		Code.put(Code.call); 
		Code.put2(offset2);
				
		// i++
		Code.loadConst(1);              // s2, i, 1
		Code.put(Code.add);             // s2, i+1

		// priprema za sledeću iteraciju
		Code.put(Code.dup2);            // s2, i, s2, i
		Code.put(Code.dup);             // s2, i, s2, i, i
		Code.put(Code.dup_x2);          // s2, i, i, s2, i, i
		Code.put(Code.pop);             // s2, i, i, s2, i
		Code.put(Code.pop);             // s2, i, i, s2
		Code.loadConst(0);              // s2, i, i, s2, 0
		Code.put(Code.aload);           // s2, i, i, s2[0]

		Code.putJump(loopStart2);
		Code.fixup(exitJump2);
		
		// ciscenje steka
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.put(Code.pop);
		Code.put(Code.pop);
	}
	
	
	@Override
	public void visit(DesignatorName designatorName) {
		Code.load(designatorName.obj);
	}
	
	
	
	
	@Override
	public void visit(FactorList_var factorList_var) {
		Code.load(factorList_var.getDesignator().obj);
	}
	
	@Override
	public void visit(FactorList_n factorList_n) {
		Code.loadConst(factorList_n.getN1());
	}
	
	@Override
	public void visit(FactorList_c factorList_c) {
		Code.loadConst(factorList_c.getC1());
	}
	
	@Override
	public void visit(FactorList_b factorList_b) {
		Code.loadConst(factorList_b.getB1());
	}
	
	
	
	@Override
	public void visit(FactorList_new_coll factorList_new_coll) {
		if(factorList_new_coll.getType().struct.getKind() == Struct.Enum) {
			Code.loadConst(1);
			Code.put(Code.add);
			
		}
		Code.put(Code.newarray);
		if(factorList_new_coll.getType().struct.equals(Tab.intType)) {
			Code.put(1);
		}
		else if(factorList_new_coll.getType().struct.getKind() == Struct.Enum) {
			Code.put(1);
			
			// inicijalizacija s[0] na 0
			Code.put(Code.dup);
	        Code.put(Code.const_n);
	        Code.put(Code.const_n);
	        Code.put(Code.astore);
		}
		else {
			Code.put(0);
		}
	}
	
	
	@Override
	public void visit(FactorList_meth factorList_meth) {
		int offset = factorList_meth.getDesignator().obj.getAdr() - Code.pc;
		Code.put(Code.call);
		Code.put2(offset);
	}
	
	
	
	
	@Override
	public void visit(AddopTermList_at addopTermList_at) {
		if(addopTermList_at.getAddop() instanceof Addop_minus) {
			Code.put(Code.sub);
		}
		else {
			Code.put(Code.add);
		}
	}
	
	@Override
	public void visit(MulOpFact_mf mulOpFact_mf) {
		if(mulOpFact_mf.getMulop() instanceof Mulop_div) {
			Code.put(Code.div);
		}
		else if (mulOpFact_mf.getMulop() instanceof Mulop_mul){
			Code.put(Code.mul);
		}
		else {
			Code.put(Code.rem);
		}
	}
	
	@Override
	public void visit(Factor_m factor_m) {
		Code.put(Code.neg);
	}
	
	
	@Override
	public void visit(Expr_d expr_d) {
		Obj funcObj = expr_d.getDesignator().obj;
		Obj arrObj = expr_d.getDesignator1().obj;
		
		Code.load(arrObj);
		
		// sum = 0
		Code.loadConst(0);              // array, sum
		
		
		Code.put(Code.dup2);             // array, sum, array, sum
		Code.put(Code.pop);             // array, sum, array
		Code.put(Code.arraylength);    // array, sum, length

		// i = 0
		Code.loadConst(0);              // array, sum, length, 0
		
		// array, sum, length, i
		
		
		int loopStart = Code.pc;

		// i < length
		Code.put(Code.dup2);            // array, sum, length, i, length, i
		Code.putFalseJump(Code.gt, 0);  // i >= length -> exit
		int exitJump = Code.pc - 2;
		
		Code.put(Code.dup_x1);           // array, sum, i, length, i
		Code.put(Code.pop);             //  array, sum, i, length
		Code.put(Code.pop);             //  array, sum, i
		
		Code.put(Code.dup);             // array, sum, i, i
		Code.load(arrObj);         		// array, sum, i, i, array
		Code.put(Code.dup_x1);          // array, sum, i, array, i, array
		Code.put(Code.pop);             // array, sum, i, array, i
		
		// a[i]
		Code.put(Code.aload);           // array, sum, i, a[i]

		// poziv func(a[i])
		int offset = funcObj.getAdr() - Code.pc;
		Code.put(Code.call); 
		Code.put2(offset);
		
		// povratnu vrednost funkcije dodati u sum
		// [array, sum, i, func(a[i])]
		Code.put(Code.dup_x1);   		// array, sum, func(a[i]), i, func(a[i])
		Code.put(Code.pop);				// array, sum, func(a[i]), i
		Code.put(Code.dup_x2);   		// array, i, sum, func(a[i]), i
		Code.put(Code.pop);				// array, i, sum, func(a[i])
		Code.put(Code.add);				// array, i, summary
		
		// i++
		Code.put(Code.dup_x1); 			// array, summary, i, summary
		Code.put(Code.pop);				// array, summary, i
		Code.loadConst(1);				// array, summary, i, 1
		Code.put(Code.add);				// array, summary, i+1
		
		// priprema steka za sledecu iteraciju -> array, sum, length, i
		Code.load(arrObj);				// array, summary, i+1, array
		Code.put(Code.arraylength); 	// array, summary, i+1, length
		Code.put(Code.dup_x1);			// array, summary, length, i+1, length
		Code.put(Code.pop);				// array, summary, length, i+1
		
		Code.putJump(loopStart);
		
		// patch skoka
		Code.fixup(exitJump);
		
		// array, summary, length, i
		Code.put(Code.pop);             
		Code.put(Code.pop);            	
		Code.put(Code.dup_x1);			
		Code.put(Code.pop);             
		Code.put(Code.pop);             // summary
		
	}
	
	
	
	//Condition
	
	private Stack<Integer> passCondFact = new Stack<>();
	private Stack<Integer> passCondition = new Stack<>();
	
	private Stack<Integer> jumpToElse = new Stack<>(); //netacan Condition -> treba raditi samo else granu
	private Stack<Integer> passElse = new Stack<>(); //tacan COndition -> treba posle then grane odmah skociti van uslova
	
	private int relOpCode(Relop relop) {
		if(relop instanceof Relop_eq)
			return Code.eq;
		else if(relop instanceof Relop_neq)
			return Code.ne;
		else if(relop instanceof Relop_gt)
			return Code.gt;
		else if(relop instanceof Relop_ge)
			return Code.ge;
		else if(relop instanceof Relop_lt)
			return Code.lt;
		else
			return Code.le;
	}
	
	@Override
	public void visit(CondFact_e condFact_e) {
		Code.loadConst(0);
		Code.putFalseJump(Code.ne, 0); // netacna
		passCondFact.push(Code.pc - 2); // fixup-ujemo kada dodje sledeci OR, jer ako je nit bila netacna, ona treba da skoci na sledeci OR
		// tacna
	}
	
	@Override
	public void visit(CondFact_ere condFact_ere) {
		Code.putFalseJump(relOpCode(condFact_ere.getRelop()), 0); // netacna; iskocicemo ako uslov iz relOpCode-a nije ispunjen
		passCondFact.push(Code.pc - 2);
		// tacna
	}

	@Override
	public void visit(CondTerm condTerm) {
		// tacna
		Code.putJump(0); // tacne bacamo na THEN
		passCondition.push(Code.pc - 2);
		// ovde vracamo netacne
		while(!passCondFact.empty()) {
			Code.fixup(passCondFact.pop());
		}
		// netacne
	}
	
	
	@Override
	public void visit(Condition_c condition_c) {
		// netacni
		Code.putJump(0); // netacne bacamo na ELSE
		jumpToElse.push(Code.pc - 2);
		// THEN
		while(!passCondition.empty()) {
			Code.fixup(passCondition.pop());
		}
		// tacne
		
	}
	
	
	@Override
	public void visit(ElseStatement_e elseStatement_e) { // else grane nije bilo
		// tacne
		Code.fixup(jumpToElse.pop());
		// tacne i netacne
	}
	
	@Override
	public void visit(ElseNonTerm elseNonTerm) { 
		// tacne
		Code.putJump(0); // tacne bacamo nakon ELSE-a
		passElse.push(Code.pc - 2);
		Code.fixup(jumpToElse.pop());
		// netacne
	}

	@Override
	public void visit(ElseStatement_els elseStatement_els) { 
		// netacne
		Code.fixup(passElse.pop()); // vracamo tacne koje su preskocile ELSE
		// netacne + tacne
	}
	
	
	
	// Do-While
	private Stack<Integer> doBegin = new Stack<>();
	
	@Override
	public void visit(DoNonterminal doNonterminal) {
		doBegin.push(Code.pc);
		breakList.push(new ArrayList<Integer>());
		continueList.push(new ArrayList<Integer>());
	}
	
	@Override
	public void visit(WhileNonterminal whileNonterminal) {
		while(!continueList.peek().isEmpty()) {
			Code.fixup(continueList.peek().remove(0));
		}
		continueList.pop();
	}
	
	@Override
	public void visit(Statement_dwc statement_dwc) {
		Code.putJump(doBegin.pop()); // tacne bacamo na pocetak DO-a
		Code.fixup(jumpToElse.pop()); // netacne bacamo na kraj petlje
		
		while(!breakList.peek().isEmpty()) {
			Code.fixup(breakList.peek().remove(0));
		}
		breakList.pop();
	}
	
	
	@Override
	public void visit(Statement_dwe statement_dwe) {
		Code.putJump(doBegin.pop()); // sve uvek bacamo na novi pocetak DO-a
		
		while(!breakList.peek().isEmpty()) {
			Code.fixup(breakList.peek().remove(0));
		}
		breakList.pop();
	}
	
	
	@Override
	public void visit(Statement_dwcd statement_dwcd) {
		Code.putJump(doBegin.pop()); // tacne bacamo na pocetak DO-a
		Code.fixup(jumpToElse.pop()); // netacne bacamo na kraj petlje
		
		while(!breakList.peek().isEmpty()) {
			Code.fixup(breakList.peek().remove(0));
		}
		breakList.pop();
	}
	
	
	
	private Stack<List<Integer>> breakList = new Stack<>();
	private Stack<List<Integer>> continueList = new Stack<>();
	
	@Override
	public void visit(Statement_br statement_br) {
		Code.putJump(0);
		breakList.peek().add(Code.pc - 2);
	}
	
	@Override
	public void visit(Statement_cn statement_cn) {
		Code.putJump(0);
		continueList.peek().add(Code.pc - 2);
	}
	
	
	private Map<String, Integer> labelList = new HashMap<>();
	private Map<String, List<Integer>> labelsToFix = new HashMap<>();
	
	@Override
	public void visit(Label label) {
		labelList.put(label.getI1(), Code.pc);
		
		if(labelsToFix.containsKey(label.getI1())) {
			while(!labelsToFix.get(label.getI1()).isEmpty())
				Code.fixup(labelsToFix.get(label.getI1()).remove(0));
		}
	}
	
	@Override
	public void visit(Statement_goto statement_goto) {
		if(labelList.containsKey(statement_goto.getI1()))
			Code.putJump(labelList.get(statement_goto.getI1()));
		else {
			Code.putJump(0);
			int patchAddr = Code.pc - 2;
			List<Integer> l;
			if(labelsToFix.containsKey(statement_goto.getI1()))
				l = labelsToFix.get(statement_goto.getI1());
			else {
				l = new ArrayList<>();
				labelsToFix.put(statement_goto.getI1(), l);
			}
			l.add(patchAddr);
		}
	}
	
}
